---
title: "Cox Model Building and Diagnostics"
output:
    html_document: 
      toc: true 
      toc_float: true 
---

# Model building
## Load the data

```{r}
library(tidyverse)
library(survival)
library(asaur)
library(broom)

dat <- pharmacoSmoking
```

## The 4 candidate models
```{r}
M0 <- coxph(Surv(ttr, relapse) ~ 1, data = dat)
MA <- coxph(Surv(ttr, relapse) ~ ageGroup4, data = dat)
MB <- coxph(Surv(ttr, relapse) ~ employment, data = dat)
MC <- coxph(Surv(ttr, relapse) ~ ageGroup4 + employment, data = dat)
```

```{r}
summary(MA)
```

```{r}
summary(MB)
```


```{r}
summary(MC)
```

## Comparing nested models: LRT
```{r}
anova(MA, MC)
```

## Comparing non-nested models: AIC
```{r}
fits <- list(MA = MA, MB = MB, MC = MC)
sapply(fits, AIC)
```

Model 'MC' is the best.

## Automatic model selection based on AIC

```{r}
Mfull <- coxph(Surv(ttr, relapse) ~ grp + gender + race +
                 employment + yearsSmoking + levelSmoking +
                 age + I(age^2) + priorAttempts + longestNoSmoke,
               data = dat)
```

```{r}
MAIC <- step(Mfull)
```

```{r}
summary(MAIC)
```
## There's only so much we can automate: transformed variables

```{r}
M_ageLinear <- MAIC
M_ageCat <- coxph(Surv(ttr, relapse) ~ grp + employment + ageGroup4, data = dat)
AIC(M_ageLinear)
AIC(M_ageCat)
```

AIC prefers a linear term of Age. However, it might not necessarily
be the best choice if the age effect is _not_ actually linear,
and we want to e.g. explicitly account for ethnicity:

```{r}
M_new <- coxph(Surv(ttr, relapse) ~ grp + race + 
                 employment + 
                 ageGroup4,
               data = dat)
summary(M_new)
```

```{r}
AIC(MAIC)
AIC(M_new)
```

# Measuring predictions performance - C statistic

## Split data into a training and a testing set
```{r}
set.seed(1234)
i.training <- sample.int(nrow(dat), size = ceiling(nrow(dat)/2), replace = FALSE)
i.testing <- setdiff(seq_len(nrow(dat)), i.training)
d_training <- dat[i.training, ]
d_testing <- dat[i.testing, ]
```

## Train 3 candidate models
```{r}
MA <- coxph(Surv(ttr, relapse) ~ gender + age, data = d_training)
MB <- coxph(Surv(ttr, relapse) ~ gender + employment, data = d_training)
MC <- coxph(Surv(ttr, relapse) ~ gender + age + employment, data = d_training)
```

## Measure predictions performance - THE **WRONG** WAY
WROOOOOONG!
THIS WOULD BE INCORRECT:
```{r}
models <- list(A = MA, B = MB, C = MC)
map_dbl(models, ~ summary(.)$concordance[1])
```
WROOOOOOOONG!!!!

The same dataset is used for both training and performance evaluation.
This will *always* favor the model with more parameters.

## Make predictions in the testing dataset
```{r}
d_testing$lp_A <- predict(MA, newdata = d_testing, type = "lp")
d_testing$lp_B <- predict(MB, newdata = d_testing, type = "lp")
d_testing$lp_C <- predict(MC, newdata = d_testing, type = "lp")

d_testing
```


## Assess predictive performance
```{r}
models <- list(
    A = coxph(Surv(ttr, relapse) ~ lp_A, data = d_testing),
    B = coxph(Surv(ttr, relapse) ~ lp_B, data = d_testing),
    C = coxph(Surv(ttr, relapse) ~ lp_C, data = d_testing)
  )

summary(models$A)
summary(models$B)
summary(models$C)
```

### 1. Check that the predictions go into the right direction
```{r}
sapply(models, coef)
```

### 2. Extract the C-statistic from the 'summary' output
```{r}
map_dbl(models, ~ summary(.)$concordance[1])
```

### 3. Flip directions as needed
```{r}
benchmark <-
  tibble(
    model = names(models),
    sign = sapply(models, coef) |> sign(),
    C_summary = map_dbl(models, ~ summary(.)$concordance[1]),
    C = ifelse(sign > 0, C_summary, 1 - C_summary)
  )
benchmark
```

```{r}
benchmark |> select(model, C)
```


# Measuring predictions performance - effect size

```{r}
d1 <- d_testing |> select(ttr, relapse, lp_A, lp_B, lp_C)
head(d1)
```

## Raw estimates
```{r}
A <- coxph(Surv(ttr, relapse) ~ lp_A, data = d1) |> tidy()
B <- coxph(Surv(ttr, relapse) ~ lp_B, data = d1) |> tidy()
C <- coxph(Surv(ttr, relapse) ~ lp_C, data = d1) |> tidy()
bind_rows(A, B, C)
```

These log-HRs are not directly comparable.

```{r}
d_testing |> select(lp_A, lp_B, lp_C) |> sapply(sd)
```

```{r}
d_testing |> select(lp_A, lp_B, lp_C) |> sapply(IQR)
```


## Standardized predictions

```{r}
d2 <- mutate(d1,
             ZA = lp_A / sd(lp_A),
             ZB = lp_B / sd(lp_B),
             ZC = lp_C / sd(lp_C))
head(d2)
```

```{r}
A <- coxph(Surv(ttr, relapse) ~ ZA, data = d2) |> tidy()
B <- coxph(Surv(ttr, relapse) ~ ZB, data = d2) |> tidy()
C <- coxph(Surv(ttr, relapse) ~ ZC, data = d2) |> tidy()
bind_rows(A, B, C) |>
  transmute(term, estimate, HR = exp(estimate), p.value)
```

## Discretized predictions - based on quantiles

```{r}
d3 <-
  mutate(d2,
         FA = factor((lp_A > median(lp_A)), levels = c(FALSE, TRUE), labels = c("low", "high")),
         FC = factor((lp_C > median(lp_C)), levels = c(FALSE, TRUE), labels = c("low", "high"))
         )

A <- coxph(Surv(ttr, relapse) ~ FA, data = d3) |> tidy()
C <- coxph(Surv(ttr, relapse) ~ FC, data = d3) |> tidy()
bind_rows(A, C) |>
  transmute(term, estimate, HR = exp(estimate), p.value)
```

```{r}
fit.KM <- survfit(Surv(ttr, relapse) ~ FA, data = d3)
fit.KM
plot(fit.KM, col = 1:2)
```

```{r}
fit.KM <- survfit(Surv(ttr, relapse) ~ FC, data = d3)
fit.KM
plot(fit.KM, col = 1:2)
```

# Model diagnostics

## Martingale residuals

```{r}
library(survival)
library(asaur) ## dataset

data(pharmacoSmoking)
dat <- pharmacoSmoking
```

```{r}
fit <- coxph(Surv(ttr, relapse) ~ grp + age + employment, data = dat)
dat$residual <- residuals(fit, type = "martingale")
```

```{r}
par(mfrow = c(1, 3), mar = c(4.2, 2, 2, 2))
with(dat, {

  plot(age, residual)
  lines(lowess(age, residual), lwd = 2)

  plot(residual ~ grp)

  plot(residual ~ employment)

})
```

```{r}
fit_better <- coxph(Surv(ttr, relapse) ~ grp + age + I(age^2) + employment, data = dat)
summary(fit_better)
```

```{r}
dat$residual <- residuals(fit_better, type = "martingale")
par(mfrow = c(1, 3), mar = c(4.2, 2, 2, 2))
with(dat, {

  plot(age, residual)
  lines(lowess(age, residual), lwd = 2)

  plot(residual ~ grp)

  plot(residual ~ employment)

})
```

## Case-deletion residuals

```{r}
dfbetas <- residuals(fit, type = 'dfbetas')
head(dfbetas)
```

```{r}
dat$dfbetas <- sqrt(rowSums(dfbetas^2))
plot(dat$dfbetas, type = 'h')
abline(h = 0)
```

## Proportionality of hazards

### Pancreatic cancer dataset - late vs early stage
```{r}
library(survival)
library(asaur) ## dataset
library(plyr)
library(ggplot2)

fmt <- "%m/%d/%Y"
dat <- as.tibble(pancreatic) %>%
  mutate(
  onstudy = as.Date(as.character(onstudy), format = fmt),
  progression = as.Date(as.character(progression), format = fmt),
  death = as.Date(as.character(death), format = fmt),
  OS = death - onstudy,
  PFS = ifelse(is.na(progression), OS, pmin(progression - onstudy, OS))) %>%
  mutate(
  PFS = Surv(as.numeric(PFS / 30.5)),
  OS = Surv(as.numeric(OS / 30.5))
  )
dat
```

```{r}
fit <- coxph(PFS ~ stage, data = dat)
summary(fit)
```

```{r}
fit.KM <- survfit(PFS ~ stage, data = dat)
plot(fit.KM, col = 1:2)
```


```{r}
fit.KM <- survfit(PFS ~ stage, data = dat)
plot(fit.KM, fun= "cloglog", col = 1:2)
```
The figure indicates violation of proportionality of the hazards.

### Pharmacosmoking dataset - treatment vs control
```{r}
fit.KM <- survfit(Surv(ttr, relapse) ~ grp, data = pharmacoSmoking)

plot(fit.KM, fun = "cloglog", col = 1:2)
```
The figure indicates no violation of the assumption of proportionality
of the hazards.

### Schoenfeld residuals
```{r}
fit <- coxph(PFS ~ stage, data = dat)
residual.sch <- cox.zph(fit)
residual.sch
```

The null hypothesis is of constant covariates effects
through time. Evidence against this hypothesis is also
evidence against the assumption of proportionality
of the hazards.

```{r}
plot(residual.sch)
```

# Dealing with assumptions violations

## Stratification

```{r}
library(asaur)
d <- pharmacoSmoking
d$employment <- ifelse(d$employment == "ft", "ft", "other")

table(d$employment)
```

Stratified Cox model:
```{r}
fit <- coxph(Surv(ttr, relapse) ~ grp + strata(employment), data = d)

summary(fit)
```

Note how there is no estimate associated with 'employment'.

## Truncation

```{r}
library(asaur)
library(survival)
d <- pancreatic2

plot(survfit(Surv(pfs, status) ~ stage, data = d), col = 1:2)
```

THIS IS *NOT* HOW IT IS DONE:
```{r}
d_WRONG <- subset(d, pfs <= 180)

plot(survfit(Surv(pfs, status) ~ stage, data = d_WRONG), col = 1:2)
```

Here is how you do it:
```{r}
d_RIGHT <- within(d, {
  status_truncated <- ifelse(pfs > 180, 0, status)
  pfs_truncated <- ifelse(pfs > 180, 180, pfs)
})
```

```{r}
plot(survfit(Surv(pfs_truncated, status_truncated) ~ stage, data = d_RIGHT),
     col = 1:2)
```

```{r}
plot(survfit(Surv(pfs, status) ~ stage, data = d_RIGHT),
     fun = "cloglog",
     col = 1:2)
plot(survfit(Surv(pfs_truncated, status_truncated) ~ stage, data = d_RIGHT),
     fun = "cloglog",
     col = 1:2)
```

```{r}
summary(coxph(Surv(pfs_truncated, status_truncated) ~ stage, data = d_RIGHT))
```
